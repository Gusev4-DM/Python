
# Работа со списками

'''
Функция lsit и квадратные скобки [] - Создание списков
Квадратные скобки [] - Доступ к элемнту по индексу
Метод append() - Добавление одного элемнта в конец
Метод extend() - Добавление нескольких элементов вконец
Метод pop() - Удаление элемента по индексу
Метод count() - подсчет вхождения элемента
Метод index() - индекс первого вхождения элемента
Метод insert() - Вставка элемнта по индексу
Метод remove() - Удаление элемнта по значению
'''

list_1 = list()
list_2 = list((3.15, True, 'Hello world'))
list_3 = []
list_4 = [3.14, True, 'Hello world']

my_list = [2, 4, 6, 8, 10, 12]

print(my_list[0]) # - Обращаемся к нулевому элемнту
print(my_list[-1]) # - Обращаемся к последнему элементу
print(my_list[-10]) # - Ошибка потому что -10 находится за пределами  индексации


#########################################################################################################


a = 42
b = 'hello'
c = [1, 3, 5, 7]
my_list = [None]
my_list.append(a) # - [None, 42]
my_list.append(b) # - [None, 42, 'hello']
my_list.append(c) # - [None, 42, 'hello', [1, 3, 5, 7]]

my_list.append(my_list) # - [None, 42, 'hello world', [1, 3, 5, 7], [...]] - Циклическая ссылка, когда объект ссылается на сам себя. Это плохой пример

#########################################################################################################

a = 42
b = 'hello'
c = [1, 3, 5, 7]
my_list = [None]
my_list.extend(a) # - Ошибка. Потому что не работает с 1-м объектом. Должен получать на вход последовательность.
my_list.extend(b) # - [None, 42, 'h', 'e', 'l', 'l', 'o'] - Берет последовательно каждую букву и добавлячет ее как отдельный элемнт в список, по 1 букве
my_list.extend(c) # - [None, 42, 'h', 'e', 'l', 'l', 'o', 1, 3, 5, 7] - Так же добавляет последовательно  каждый элемент

#########################################################################################################

my_list = [2, 4, 6, 8, 10, 12]

spam = my_list.pop()
print(spam, my_list) # - 12 [2, 4, 6, 8, 10] # Pop - не просто удаляет, а возвращает элемент в переменную

egs = my_list.pop(1)
print(spam, my_list) # - 4 [2, 6, 8, 10] # Берет тот элемнт который мы указали в качестве индекса. Несуществующий индекс выдаст ошибку индекса

#########################################################################################################

my_list = [2, 4, 6, 2, 8, 10, 4, 12, 12, 10, 6]

spam = my_list.count(2) # Выведет 2, потому что двойка встречается в списке 2 раза. Если число ниразу не встретилось, то выведет 0

#########################################################################################################

my_list = [2, 4, 6, 2, 8, 10, 4, 12, 12, 10, 6]

spam = my_list.index(4) # Выведет 2, потому что число 4 имеет индекс 1.

egs = my_list.index(4, spam + 1, 90) # Может принимать два значения: Старт, Стоп. Ищу 4-ку начиная с 1-го индекса массива spam до 90-го индекса.
# Ошибку не вызывает, потому что мы дошли до конца списка и вернули какой-то ответ. Если число не найдется то выведет ошибку.

#########################################################################################################

my_list = [2, 4, 6, 8, 10, 12]

my_list.insert(2, 555) # - [2, 4, 555, 6, 8, 10, 12] - 2 то индекс, 555 это значение
my_list.insert(-2, 13) # - [2, 4, 555, 6, 8, 13, 10, 12] - -2 индекс вставляется число 13
my_list.insert(42, 73) # - [2, 4, 555, 6, 8, 13, 10, 12, 73] - в 42-ю позицию(т.е последнюю) вставлется число 73
# Если нужно вставить число в конец, лучше использовать append(). Работает быстрее

#########################################################################################################

my_list = [2, 4, 6, 8, 10, 12, 6]

my_list.remove(6) # - my_list = [2, 4, 8, 10, 12, 6] - Убралась 6 в индексе 2. Потому что она встретилась первой
my_list.remove(3) # - Ошибка. Такого числа нет

#########################################################################################################

'''
Сортировка

1. Функция sorted() - Сортирует элемнты. Может принимать не только списки но и любые последовательности в.т.ч кортеж или множества
2. Метод sort() - Сортирует только список


Разворот

1. Функция reversed()
2. Метод reverse()
3. Синтаксический сахар [::-1]
'''

my_list = ['h', 'e', 'l', 'l', 'o', 1, 3, 5, 7]
my_list.sort() # - Ошибка потому что в списка числа и строки
res = sorted(my_list) # - Ошибка, по той же причине

# Как сортировать правильно
my_list = [4, 8, 2, 9, 1, 7, 2]
sort_list = sorted(my_list)
print(my_list, sort_list, sep='\n') # [4, 8, 2, 9, 1, 7, 2] и [1, 2, 2, 4, 7, 8, 9]
rev_list = sorted(my_list, reverse=True)
print(my_list, rev_list, sep='\n') # [4, 8, 2, 9, 1, 7, 2] и [9, 8, 7, 4, 2, 2, 1]

#########################################################################################################

# Отсоритровать список не создавая новый объект

my_list = [4, 8, 2, 9, 1, 7, 2]

my_list.sort(reverse=True)


# Развороты

my_list = [4, 8, 2, 9, 1, 7, 2]
res = reversed(my_list)
print(type(res), res) # - <class list_reversiterator>, <object at 0x000001BE6D536080>

rev_list = list(reversed(my_list))
print(rev_list) # - [2, 7, 1, 9, 2, 8, 4] - Получился реверс

for i in reversed(my_list):
    print(i)
# Например вот так можно его использовать

#########################################################################################################

my_list = [4, 8, 2, 9, 1, 7, 2]
my_list.reverse()
print(my_list)

my_list = [4, 8, 2, 9, 1, 7, 2]
new_list = my_list[::-1] # - Срез от начала до конца списка, в обратном порядке
print(my_list, new_list, sep='\n')


'''
Срезы
list[start:stop:step]

Метод copy() - Создает поверхностную копию

Функция copy.deepcopy() - Создает полную рекурсивную копию
'''

# Срезы

my_list = [2, 4, 6, 2, 8, 10, 12, 14, 16, 18]
print(my_list[2:7:2]) # 2 - старт, 7 - стоп, 2 - шаг
print(my_list[:7:2]) # старт с 0, 7 стоп, шаг 2
print(my_list[2::2]) # 2 - старт, до конца без стопа, 2 - шаг
print(my_list[2:7:]) # начинаем с 2-го индекса до 7, без шага
print(my_list[8:3:-1]) # От 8-го индекса, до 3-го, начинаем с конца. Вывод будет такой [16, 14 , 12, 10, 8]
print(my_list[3::]) # Начинаем с 3 и до конца без шага
print(my_list[:7:]) # Начинаем с начала до 7, без шага

# ВАЖНО! Элемент который указан как Старт - включается в срез.
# ВАЖНО! Элемент который указан как Стоп - в срез не включается.

# Copy

my_list = [2, 4, 6, 2, 8, 10, 12, 14, 16, 18]
new_list = my_list
print(my_list, new_list, sep='\n')
my_list[2] = 555
print(my_list, new_list, sep='\n')
# Оба списка будут одинаковые потому что ссылаются на один объект


# Чтобы создать два разных объекта воспользуемся методом copy()
my_list = [2, 4, 6, 2, 8, 10, 12, 14, 16, 18]
new_list = my_list.copy()
print(my_list, new_list, sep='\n')
my_list[2] = 555
print(my_list, new_list, sep='\n')

# Но не все так просто

matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] # Это матрица, или список списков
new_m = matrix.copy() # Copy это только поверхностная копия. И не делает копию вложенности внутри матрицы
print(matrix, new_m, sep='\n')
matrix[0][1] = 555
print(matrix, new_m, sep='\n')

# Есть решение

import copy

matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
new_m = copy.deepcopy(matrix) # Глубокая копия матрицы. Рекурсивно обходит все структуры, не зависимо от глубины вложенности
print(matrix, new_m, sep='\n')
matrix[0][1] = 555
print(matrix, new_m, sep='\n')
# Другое дело

# Копии занимают много ресурсов, поэтому при работе смаленькими данными ничего страшного нет.
# Однако при использовании больших данных это будет трудозатратно для компьютера


'''
Функция len()
'''

# len(x) - Возвращает целое число - количество элементов колекции.
# Не учитывает вложенные колекции.

my_list = [2, 4, 6, 2, 8, 10, 12, 14, 16, 18]
matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
print(len(my_list)) # Будет 10
print(len(matrix)) # Будет 3
print(len(matrix[1])) # Будет 4


'''
Строки, str

Квадратные скобки []
    - Доступ к элемнтау по индексу
    - Срезы строк
    - Реверс строк

Метод count() - Подсчет вхождения элемента
Метод index() - Индекс первого вхождения элемнта
Метод find() - Индекс первого вхождения элемнта
'''

text = 'Hello world!'
print(text[6]) # w
print(text[3:7]) # lo w

new_txt = text.replace('l', 'L', 2) # Используем метод replace() потому что строка не изменяемая
# l - Симфол который хотим заменить, L - На какой меняем, 2 - Количество замен. Если число не указываем, то все будут заменены
print(text, new_txt, sep='\n') # Hello world! и HeLLo world!


# Метод count, index, find

text = 'Hello world!'
print(text.count('l')) # 3
print(text.index('l')) # 2
print(text.find('l')) # 2
print(text.find('z')) # -1. Возвращает -1 потому что не смог найти такой элемент


# Реверс строк

text = 'Hello world!'
print(text[::-1])


'''
Форматирование строк

Форматирование через % - Сохранился в некоторых модулях
Метод format() - Строковый метод, заменяющий фигурные скобки на перменные
f-строчка - Сочетание неизменяемого текста и переменных в фигурных скобках
'''

# Форматирование через %

name = 'Alex'
age = 12
text = 'Меня зовут %s и мне %d лет' % (name, age)
print(text)

# Метод format()

name = 'Alex'
age = 12
text = 'Меня зовут {} и мне {} лет'.format(name, age)
print(text)

# f-строка

name = 'Alex'
age = 12
text = f'Меня зовут {name} и мне {age} лет'
print(text)
print(f'{{Фигурные скобки}} и {{name}}') # - {Фигурные скобки} и {name}

# уточнение формата

pi = 3.1415
print(f'Число Пи с точностью два знака: {pi:.2f}')

data = [3254, 4364314532, 43465474, 2342, 462256, 1747]

for item in data:
    print(f'{item:>10}')

num = 2 * pi * data[1]
print(f'{num = :_}')

# ● :.2f — Число пи выводим с точность два знака после запятой

# ● :>10 — Элементы списка выводятся с выравниванием по правому краю и
# общей шириной вывода в 10 символов. "<" - По левому краю. "^" - По центру.

# ● = — Выводим имя переменной, знак равенства с пробелами до и после него и
# только потом значение. Имя переменной, пробел, равно, пробел.

# ● :_ — Число разделяется символом подчёркивания для деления на блоки по 3
# цифры.


'''
Строковые методы

Метод split() - Разбивает строку на отдельные элементы
Метод join() - Формирует строку из отдельных элементов
Методы upper(), lower(), title(), capita;ize() - Измеение регистра
Методы startswith() и endswith() - Проверка на совпадение с началом иликонцом строки
'''


# Метод split()

link = 'https://habr.com/ru/users/dzhoker1/posts/'
urls = link.split('/')
print(urls)

a, b, c = input('Введите 3 числа через пробел: ').split()
print(c, b, a)

a, b, c, *_ = input('Введите не менее трех чисел через пробел: ').split()
# *_ Обозначает то что мы хотим упаковать все лишнее кроме a b c в это нижнее подчеркивание


# Метод join()

data = ['https:', '', 'habr.com', 'ru', 'users', 'dzhoker1',
'posts']
url = '/'.join(data)
print(url)


# Методы upper(), lower(), title(), capita;ize()

text = 'однажды в СТУДЁНУЮ зИмнЮЮ ПоРУ'
print(text.upper())
print(text.lower())
print(text.title())
print(text.capitalize())


# Методы startswith() и endswith()

text = 'Однажды в студёную зимнюю пору'
print(text.startswith('Однажды'))
print(text.endswith('зимнюю', 0, -5)) # Принимает индексы старта и стопа. Проверка от начала (нулевой ячейки) до минус 5-й.


'''
Кортежи tuple
Создать кортеж можно четырьмя способами.
a = ()
b1 = 1,
b2 = (1,)
c1 = 1, 2, 3,
c2 = (1, 2, 3)
d = tuple(range(3))
print(a, b1, b2, c1, c2, d, sep='\n')

Работа с кортежем
1. Обращениеп к лементу по индексу
2. Срезы
3. Методы count(), index()
4. Функция len()

Особенность кортежей
1. f(a, b, c) - Это выхов функции с тремя агрументами
2. f((a, b, c)) - Это вызов функции с кортежем в качестве единственного аргумента, внутри которого 3 элемента
'''

print(type('text',)) # Не смотря на запятую type выведет class str, потому что type то функция, 
# А для того что туда передать кортеж необходимо обернуть аргумент двойными кавычками.


'''
Словари dict()

dict(x) - Создаем словарь
{key: value} - Тоже создаем словарь
'''

# Способы создания словареей

a = {'one': 42, 'two': 3.14, 'ten': 'Hello world!'}
b = dict(one=42, two=3.14, ten='Hello world!')
c = dict([('one', 42), ('two', 3.14), ('ten', 'Hello world!')])
print(a == b == c)


# Добавление нового элемента

my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4}
my_dict['ten'] = 10 # Создаем новый ключ указывая квадратные скобки и название ключа в них
print(my_dict)


# Доступ к значению словаря
# dict[key] - доступ через квадратные скобки. Обратится к ключу
# dict.get(key[, default]) - доступ через метод get

TEN = 'ten'
my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'ten': 10}
print(my_dict['two'])
print(my_dict[TEN]) # Используем константу TEN
print(my_dict[1]) # KeyError: 1. Не верное обращение по ключу


# Доступ через метод get

my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'ten': 10}
print(my_dict.get('two')) # Даст 2
print(my_dict.get('five')) # None. ключ отсутсвует
print(my_dict.get('five', 5)) # Даст 5 потому что указано значение по умолчанию т.к мы не смогли найти ключ five
print(my_dict.get('ten', 5)) # Даст 10 потому что такой ключ есть. Значение по умолчанию игнорирует


'''
Работа со словарями

Метод setdefault() Похож не get, но отсутствующий ключ добавляется в словарь.
Метод keys() Возвращает объект-итератор dict_keys.
Метод values() Похож на keys, но возвращает значения в виде объекта итератора dict_values, а не ключи.
Метод items() Если в цикле необходимо работать одновременно с ключами и значениями, как с
парами, используют метод items.
Метод popitem() Для удаления последней пары ключ-значение из словаря.
Метод pop() Удаляет пару ключ-значение по переданному ключу.
Метод update() Используют для расширение словаря новыми значениями.
'''

# Метод setdefault() 

my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'ten': 10}
spam = my_dict.setdefault('five') # Добавляем ключ five потому что его нет и значение None потому что оно неуказано
print(f'{spam = }\t{my_dict=}')
eggs = my_dict.setdefault('six', 6) # Добавляем новое значение с ключом six и значением 6 
print(f'{eggs = }\t{my_dict=}')
new_spam = my_dict.setdefault('two') # Значение есть выводим его
print(f'{new_spam=}\t{my_dict=}')
new_eggs = my_dict.setdefault('one', 1_000) # Значение есть изменений не будет
print(f'{new_eggs=}\t{my_dict=}')

# Метод keys()

my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'ten': 10}
print(my_dict.keys())
for key in my_dict.keys(): # Можно убрать .keys() Потому что для словарей если мы не указываем никакой метод, то автоматически идет итерация по ключам
    print(key)

# Метод values()

my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'ten': 10}
print(my_dict.values())
for value in my_dict.values():
    print(value)

# Метод items()

my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'ten': 10}
print(my_dict.items())
for tuple_data in my_dict.items(): # Плохо
    print(tuple_data)
for key, value in my_dict.items(): # Хорошо
    print(f'{key = } value before 100 - {100 - value}')


# Метод popitem()

my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'ten': 10}
spam = my_dict.popitem()
print(f'{spam = }\t{my_dict=}')
eggs = my_dict.popitem()
print(f'{eggs = }\t{my_dict=}')


# Метод pop()

my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'ten': 10}
spam = my_dict.pop('two')
print(f'{spam = }\t{my_dict=}')
err = my_dict.pop('six') # KeyError: 'six'
err = my_dict.pop() # TypeError: pop expected at least 1 argument, got 0
# Без пререданных ключей мы будем получать ошибки


# Метод update()

my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'ten': 10}
my_dict.update(dict(six=6))
print(my_dict)
my_dict.update(dict([('five', 5), ('two', 42)]))
print(my_dict)

my_dict = {'one': 1, 'two': 2, 'three': 3, 'four': 4, 'ten': 10}
new_dict = my_dict | {'five': 5, 'two': 42} | dict(six=6) # Вертикальная черта позволяет объеденить словари в один новый словарь
print(new_dict)


'''
Множества set и frozenset
'''

my_set = {1, 2, 3, 4, 2, 5, 6, 7} # Изменяемое множество
print(my_set)
my_f_set = frozenset((1, 2, 3, 4, 2, 5, 6, 7,)) # Не изменяемое множество
print(my_f_set)
not_set = {1, 2, 3, 4, 2, 5, 6, 7, ['a', 'b']} # TypeError: unhashable type: 'list'. Внутри множества находится list - Изменяемый тип данных


'''
Работа с множествами

1. Метод add() - Работает аналогично методу списка append, т.е. добавляет один элемент в коллекцию.
2. Метод remove() - Используют для удаления элемента множества.
3. Метод discard() - Работает аналогично remove — удаляет один элемент множества
4. Метод intersection() - Используют для получения пересечения множеств, т.е. множества с элементами, которые есть и в левом и в правам множестве.
5. Метод union() - Используют для объединения множеств.
6. Метод difference() - Удаляет из левого множества элементы правого.
'''


# Метод add()

my_set = {3, 4, 2, 5, 6, 1, 7}
my_set.add(9)
print(my_set)
my_set.add(7)
print(my_set)
my_set.add(9, 10) # TypeError: set.add() takes exactly one argument (2 given)
my_set.add((9, 10)) # Добавит, потому что это отдельный уникальный элемент, не смотря на то что внутри есть свои элементы
print(my_set)


# Метод remove()

my_set = {3, 4, 2, 5, 6, 1, 7}
my_set.remove(5)
print(my_set)
my_set.remove(10) # KeyError: 10


# Метод disacard()

my_set = {3, 4, 2, 5, 6, 1, 7}
my_set.discard(5) # Удалится, все ок
print(my_set)
my_set.discard(10) # Ошибки не будет. При отсутсвии операция будет проигнорирована.


# Метод intersection()

my_set = {3, 4, 2, 5, 6, 1, 7}
other_set = {1, 4, 42, 314}
new_set = my_set.intersection(other_set) # Ищет только пересечения двух множеств
print(f'{my_set = }\n{other_set = }\n{new_set = }')

my_set = {3, 4, 2, 5, 6, 1, 7}
other_set = {1, 4, 42, 314}
new_set = my_set & other_set # В новых версиях Python можно сделать так
print(f'{my_set = }\n{other_set = }\n{new_set = }')


# Метод union()

my_set = {3, 4, 2, 5, 6, 1, 7}
other_set = {1, 4, 42, 314}
new_set = my_set.union(other_set) # Объединяет множества
print(f'{my_set = }\n{other_set = }\n{new_set = }')

new_set_2 = my_set | other_set # Альтернативный вариант
print(f'{my_set = }\n{other_set = }\n{new_set_2 = }')


# Метод difference()

my_set = {3, 4, 2, 5, 6, 1, 7}
other_set = {1, 4, 42, 314}
new_set = my_set.difference(other_set) # Разница множеств. Только уникальные множества первого объекта (my_set). Одинаковые значения из второго и первого - убираются.
print(f'{my_set = }\n{other_set = }\n{new_set = }')

new_set_2 = my_set - other_set # Альтернативный вариант
print(f'{my_set = }\n{other_set = }\n{new_set_2 = }')


'''
Проверка на вхождение in

Слово in позволяет сделать проверку на вхождение и в других
коллекциях. Входит ли объект в list, tuple, является ли подстрока частью строки
str, встречается ли ключ в словаре.
Для list, tuple, str проверка на вхождение работает за линейное время O(n).
Для dict, set, frozenset проверка работает за константное время O(1).
'''
my_set = {3, 4, 2, 5, 6, 1, 7}
print(42 in my_set) # False


'''
Байты, bytes и bytearray 
'''

# Байты можно получить из строки

text_en = 'Hello world!'
res = text_en.encode('utf-8')
print(res, type(res)) # Выведет - b'Hello world' <class 'bytes'>. Символ b - Говорит нам о том что переда нами набор байтов а не строка
text_ru = 'Привет, мир!'
res = text_ru.encode('utf-8')
print(res, type(res)) # Выведет b'\xd0\x9f\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82, \xd0\xbc\xd0\xb8\xd1\x80!' <class 'bytes'>.
# Потому что используется русский язык, который требует больше байтов на символ.

# Для получения набора байт можно использовать функцию bytes (Изменяемые). А если необходимо изменять байт, использую функцию bytearray (Не изменяемые)

x = bytes(b'\xd0\x9f\xd1\x80\xd0\xb8')
y = bytearray(b'\xd0\x9f\xd1\x80\xd0\xb8')
print(f'{x = }\n{y = }')


